# Углублённое изучение ЯП Python

Преподаватель: Кухтичев Антон Алексеевич

Программа: 14 лекций + ДЗ, квизы перед каждой лекцией (5 минут опрос материала),
в конце экзамен. Оценка идёт в диплом.

Дедлайны по ДЗ:

1) До конца курса (снижение оценки)
2) Две недели после выдачи ДЗ (без снижения оценки)

Материалы: [Github репозиторий курса](https://github.com/toshunster/mai_deep_python_autumn_2023)

## Занятие №1 (21.09) Тема: Введение в Python

Python - интерпретируемый ЯП с утиной типизацией (динамической), со сборщиком мусора
и GIL (Global Interpreter Lock)

Python - спецификация языка (как и стандарты C++).

Реализации:

- Cpython (Си)
- Jython (Java)
- PyPy
- IronPython (C#)

Работаем с Python >= 3.10
Дзен Python (import this) - то как должен выглядеть код на Python

### Объект

В Python всё является объектом (классы, функции, списки и тд).
Каждый объект имеет идентичность (id), тип, значение.

1) ID никогда не меняется после создания
2) Тип показывает, какие функции могут использоваться с объектом
3) Значение может меняться

- Все создаваемые объекты - экземпляры Сишного класса PyObject.
- dir(object) - выводит список функций, используемых с данным объектом

## Переменные

Допустимые символы для имени переменной: буквы (Unicode), цифры (не может быть в начале имени),
или нижнее подчёркивание.

В имени переменной согласно PEP 3131 должны использоваться только ASCII символы.

Также нельзя использовать зарезервированные имена и имена, используемые в подключаемых пакетах.

Присваивание новой переменной другой переменной приводит к ссылке на уже существующий объект,
а не копирование его значений.

Целочисленные значения [-5, 257) хэшируются,
поэтому присваивание переменной значения из этой области будет ссылаться на один и тот же PyObject

## Базовые типы переменных

Неизменяемые:

- int, float, bool, complex
- str, bytes
- tuple
- frozenset

Изменяемые:

- list
- dict, set
- user defined

### Числа

Все числа с длинной арифметикой (BigInt)
Целые числа (int):

- 42
- 42_000_000 (символ _ выступает как разделитель разрядов)
- 0o10 (8 ричная СС)
- 0x10 (16 ричная СС)

Операции:

- Стандартные арифметические операции
- (&, |, ~, ^, <<, >>) - битовые операции

### Строки

Все строки по умолчанию являются Unicode

- "str"
- b"str" - байтовая строка
- r"str" - сырая строка без экранирования, форматирования и тд

Форматирование строк:

- f-строки (самые быстрый и удобный способ)
- str.format()
- оператор %

### Коллекции

- Список (list) - реализован, как динамический массив Си

- Кортеж (tuple) - неизменяемый список

- Swap (смена значений) - работает с двумя кортежами:
    - a, b = b, a
- Распаковка (присвоение одной переменной списка значений с нефиксированным количеством элементов)
    * a, b* = list(<elements>)
- Словарь
- Множество (set, frozenset)

Основные функции и операторы работающие с коллекциями:

- _ in <iter_object> это итерирование по объекту
- sort (sorted) - сортировка коллекции in_place (на копии).
    * obj.sort / sorted(obj)

### Типы с одним значением

- None / NoneType - пустое значение (аналог nullptr из C++)
- NotImplemented
- Ellipsis (...)

## Управляющие конструкции

### Условный оператор

- if-elif-else - стандартный оператор условия
- Pattern matching (3.10) - аналог switch из C++

### Исключения

Обработкой исключений занимается: try-except-else-finally

После try пишем код с потенциальной ошибкой,
после пишем except <ожидаемый exception>,
else (вызывается, если ни один из exception не был вызван),
finally (вызывается после обработки всех исключений)

### Работа в терминале

python3 -m <название папки> venv - создание виртуального окружения python

Активация виртуального окружения:

- source venv/bin/activate (bash)
- ./venv/Scripts/activate.bat (Windows)

## Домашняя работа (1 лекция):

- Выполнить homework.md, необходимо реализовать игру в крестики-нолики.

# Лекция №2 (28.09.23)

## Тема: Функции. Декораторы. Тестирование.

Фукнция - объект (как и всё в питоне), используется для вызова многократно повторяющихся фрагментов кода,
который реализует одно логически обособленное действие (не надо внутрь одно функции пихать десяток несвязанных действий)

Для создания функции используется ключевое слово `def`, после него указывается имя функции и в круглых скобках параметры
функции. Чтобы что-то вернуть из функции используется ключевое слово `return`, если его не указать, будет
возвращён `None`

Правила именования функций:

+ имя состоит из букв, чисел, знака подчёркивания(_)
+ не начинается с цифры
+ если первый символ - знак подчёркивание, то функция приватная (это лишь общая договорённость)
+ в питоне используется snake_case, поэтому каждое слово в названии отделяется нижним подчёркиванием

Пример создания функции:

``` python
def sqrt(x: int):
return x ** 0.5

»> sqrt(4)
```

### Аргументы функции

- Функция может принимать произвольное количество аргументов (в том числе и 0)
- У аргументов могут быть значения по умолчанию (те значения, которые они примут, если их не указать явно)
- Для аргументов по умолчанию не следует использовать изменяемые значения (эти объекты создаются один раз, из-за чего
  можно получить неожиданный результат от работы функции)
- Аргументы функций бывают **именованные** и **позицонные**
- Позиционные аргументы зависят от порядка передачи их в функцию
- Именованные аргументы зависят только от своего имени
- Аргументы со значениями по умолчанию указываются в самом конце
- Для передачи неопределённого кол-ва позиционных аргументов, используется `*args` (название - соглашение, может быть
  использовано другое)
- Для передачи неопределённого кол-ва именованных аргументов, используется `**kwargs` (название - соглашение, может быть
  использовано другое)
- Звёздочка в аргументах означает, что все аргументы справа от неё - именованные (см `func4`)
- Бэкслеш означает, что все аргументы слева от него - позционные (см `func5`)

P.S. Неопределённое кол-во аргументов тесно связано
с [упаковкой и распаковкой коллекций](https://fullstacker.ru/operatory-upakovki-i-raspakovki-kollektsiy)

Пример:

``` python
def func(a, b, c = 2):
return a + b + c

def func2(*args):
    return sum(args)
    
def func3(**kwargs):
    for key, value in kwargs:
        print(f"{key} - {value}")
        
def func4(*, val):
    return val * 10

>>> func4(5) # Ошибка, позиционных аргументов функция не принимает
>>> func4(val=16) # OK

def func5(start, end, /):
    return end - start

>>> func5(start = 10, end = 16) # Ошибка
>>> func5(10, 16) # OK
```

Все возможные методы указания аргументов можно комбинировать между собой, если это не противоречит их логике.

### Декораторы

Декоратор - это функция, которая принимает единственный аргумент (другую функцию) и выполняющая дополнительную логику.
Другими словами, декоратор - обёртка над переданной функцией

В качестве примера используем декоратор, выводящий время начала и конца работы функции:

``` python
import time

def timer(func):
  def wrapper(*args, **kwargs):
    start = time.time()
    print(f"Функция {func.__name__} начала свою работу в {start}")
    res = func(*args, **kwargs)
    end = time.time()
    print(f"Функция {func.__name__} закончила свою работу в {end}")
    return res
  return wrapper
```

Теперь о том, как применять этот декоратор к каким-либо функциям:

- Создать объект от этого декоратора
- Применить синтаксический сахар для декораторов

``` python
def add(a, b, c = 0):
return a + b + c

add = timer(add) # создание объекта функции через декоратор

»> add(5, 6, 10)
```

После этого объект `add` будет ссылаться на функцию `wrapper`, а следовательно и вызывать будет её

Для применения синтаксического сахара, необходимо использовать `@decorator_name` перед созданием функции, где
decorator_name - имя функции декоратора, в нашем случае `timer`

``` python
@timer
def add(a, b, c = 0):
return a + b + c
```

``` python
def fibonacci(n):
def _fibonacci(n):
if n < 2:
return 1
return _fibonacci(n - 1) + _fibonacci(n - 2)
```

### Параметризованные декораторы

Это декораторы, которые зависят от какого-либо принимаемого значения (появляется параметризованный декоратор, который
обрабатывает этот самый параметр)

Пример:

``` python
# Функция, обрабатывающая параметр задержки, передающая его в декоратор
def sleeper(delay):
def _sleeper(func):
def wrapper(*args, **kwargs):
time.sleep(delay)
res = func(*args, **kwargs)
return res
return wrapper

return _sleeper

# Фикция, иммитирующая долгую загрузку какого-то ресурса
@timer
2
def fetch_slow(url):
time.sleep(2)
return None

# Аналогично, но загрузка быстрее
@timer
0.1
def fetch_fast(url):
time.sleep(0.5)
return None
```

После создания декоратора с параметром, можно вызвать декоратор с передачей параметра `@sleeper(time)`

Как получить исходную функцию без дополнительной логики?

Нам понадобится библиотека functools и ещё один декоратор. Перепишем наш декоратор `timer`

``` python
import time
import functools

def timer(func):
@functools.wraps(func)
def wrapper(*args, **kwargs):
start = time.time()
print(f"Функция {func.__name__} начала свою работу в {start}")
res = func(*args, **kwargs)
end = time.time()
print(f"Функция {func.__name__} закончила свою работу в {end}")
return res
return wrapper
```

После этих манипуляций, у нашей функции `add` появится новое поле `__wrapped__`, которое является исходной функцией, а
имя функции так же заменится на исходное

``` python
# ДО
»> add.__name__ # 'wrapper'
# ПОСЛЕ
»> add.__name__ # 'add'
```

Полезные функции из functools:

- `reduce`
- декоратор `lru_cache`

Декоратор `lru_cache` (Least recently used) - кэш наиболее используемых значений (при добавлении нового значения в кэш,
если этот самый кэш переполнен, удаляется значение, которое за определенный период вызывалось раньше всех). Реализован в
виде словаря `значение аргумента` - `результат выполнения функции` (есть вариации с хеш-таблицей, списком).

Параметры `lru_cache`

- `maxsize` - размер кэша
- `typed` - раздельное хранение разных типов данных

``` python
def fibonacci(n):
@functools.lru_cache(maxsize = 128, typed = False)
  def _fibonacci(n):
    if n < 2:
      return 1
  return _fibonacci(n - 1) + _fibonacci(n - 2)
```

То есть, `lru_cache` сохраняет ранее подсчитанные значения функции и подставляет их в случае необходимости повторного
вычисления. Это очень полезно при работе с рекурсивными фунциями или функциями, где определенные этапы вычисления
повторяются много раз с теми же результатами.

### Функтор

Функтор - экземпляр класса, который является вызываемым объектом (функцией).
Для создания функтора, необходимо реализовать магический метод `__call__` в пользовательском классе:

``` python
class A:
    def __init__(self):
        pass
    
    def __call__(self, a, b):
        return a + b

>>> a = A()
>>> a(5, 7) # 12
```

### Лямбда-функции

Это анонимные функции, существующие только внутри области создания и полностью пропадающие после выхода из неё. Полезны
в случаях, когда нужна одноразовая функция, работают быстрее классических (но читаемость кода порой может упасть).
Анонимные функции в силу своей простоты являются по большей части вычислительными, не могут содержать в себе циклы,
ветвления и прочие конструкции. Прекрасно подходят для написания компараторов, функций для фильтрации и т.д.
Объявление лямбда-функции происходит с помощью ключевого слова `lambda`, после него перечисляются аргументы, после
двоеточия пишется возвращаемое выражение

Пример:

``` python
func = lamdba x, y: x + y
>>> func(4, 8) # 12
```

Пример использования лямбда-функции для компоратора в сортировке объектов пользовательского класса:

``` python
class Car:
    def __init__(self, year, color)
        self.year = year
        self.color = color
    
    def __repr__(self):
        return f"Эта машина {self.color} цвета, была выпущена в {self.year} году"
```

Если мы создадим список объектов класса `Car` и попытаемся его отсортировать, то потерпим неудачу, ведь питон не
понимает, как именно сравнивать разные экземпляры этого класса, для этого воспользуемся анонимной функцией

``` python
lst = [Car(1975, "red"), Car(1960, "blue"), Car(2022, "black")]
sorted(lst, key=lambda car: car.year)
```

Таким образом, мы показали, что сортировку нужно производить, основываясь на значении поля `year`

### Атрибуты функций

- `__dict__` - содержит в себе все имена переменных внутри функции
- `__doc__` - описание функции (задаётся с помощью docstring сразу после объявления функции)
- `__name__` - название функции
- `__qualname__` - полное имя функции (со всеми зависимостями, начиная с глобального пространства)
- `__defaults__` - кортеж дефолтных значений для позиционных аргументов
- `__kwdefaults__` - словарь дефолтных значений для именованных аргументов
- `__closure__` - кортеж свободных переменных (переменные, которые были созданы во внешней/родительской функции), сам
  кортеж принадлежит внутренней функции

### Пространства имён

Пространство имен - это совокупность всех опредленных на данный момент символических имён и информации об объектах, на
которые они ссылаются. Простыми словами - все возможные объекты и информация о них в конкретный момент времени.

В питоне пространства имён бывают:

- Встроенное (пространство интерпретатора, создаётся и удаляется вместе с началом/концом его работы)
- Глобальное (пространство основной программы, хранит все имена из неё + при импорте модулей, для каждого создаётся
  собственное пространство)
- Объемлющее (пространство имён для внешний функций)
- Локальное (пространство имён функции, существует до конца её выполнения)

Пространства имён тесно связаны с областью видимости - часть программы, в котором имя обладает каким-либо значением.
Иерархия поиска имени по пространствам имён (LEGB):

1. Локальная
2. Объемлющая
3. Глобальная
4. Встроенная

LEGB = LOCAL -> ENCLOSING-> GLOBAL -> BUILT-IN

Словари `globals()` и `locals()` содержат в себе соответственно глобальные и локальные переменные относительно данного
участка кода.
Ключевые слова `global` (из глобальной) и `nonlocal` (из объемлющей) используются для разрешения конфликтных ситуаций
между пространствами имён
(когда интерпретатор не может выполнить изменение переменной или нужно указать, из какой области видимости необходимо
взять значение)

``` python
def func1():
    var = 1
    def func2():
        var = 100
        print(var)
    print(var)

>>> func1() # 1 \n 100
```

Если же, мы попытаемся внутри функции `func2` использовать значение `var` из внешней функции (как-то его изменить), то
получим ошибку, говорящую о том, что такого объекта нет. То есть, для изменения переменной из объемлющей области
видимости,
её надо объявить с помощью ключевого слово `nonlocal`, а для переменной из глобальной области видимости - с
помощью `global`:

``` python
#code here#
    def func2():
        nonlocal var
        var = var + 10
#code here#
```

``` python
var = 5

def f1():
    var = 10
    def f2():
        global var
    #code here#
```

P.S. Подобного конфликта имен не возникает при работе с изменяемыми объектами, поскольку они копируются, а не создаются
новые.

### Встроенные функции Python (в аргументах используется функция)

- `map (func, iterable, [iterable2, ...])` - применяет указанную функцию к каждому элементу переданных итерируемых
  объектов (в одной итерации берётся по одному элементу из каждой последовательности). Итерация происходит по объекту
  наименьшей длины. После работы возвращает генератор.

``` python
def func(*args):
    return "|".join([str(i) for i in args])

list(map(func, [1, 2], [3, 5, 6], [6, 4, 6]))
```

- `reduce (func, iterable[ , initializer])` - применяет указанную функцию к элементам последовательности, сводя её к
  единственному значению (похоже на агрегирующую фукнкцию в SQL). Находится в модуле `functools`

``` python
from itertools import reduce
items = [1, 3, 5, 6, 8]
sum_all = reduce(lambda x, y: x + y, items)
```

Данная функция проходит по всем элементам `items`, при чём `x` равен значению из `initializer` (по умолчанию равен 0),
а `y` равен значению из первого элемента списка. В последующих итерациях, `x` будет присвоен результат выполнения
функции на прошлой итерации, а `y` следующее значение из списка.

- `partial(func, *args, **keywords)` - шаблон для использования уже реализованной функции с определённо заданными
  аргументами.

``` python
basetwo = partial(int, base=2)
>>> basetwo('10010') #18
```

То есть, с помощью `partial`, мы создали функцию, которая работает, как встроенная функция `int`, но с основанием 2.

- `filter(func, iterable)` - фильтрация значений в итерируемом объекте. Если функция работающая по данному элементу
  возвращает `True`, то этот элемент остаётся в коллекции, иначе элемент удаляется.

``` python
filter(lambda x: x % 2 == 0, [1, 4, 6, 9]) # 4 6
```

В примере выше, мы отфильтровали список и оставили в нём только чётные элементы.

- `zip(*iterables, strict=False)` - объединяет в кортежи элементы с одинаковым порядковым номером в коллекциях,
  переданных в функцию. Обход происходит по объекту с наименьшим количеством элементов. `strict` используется для
  проверки идентичности длин последовательностей.

``` python
a = [1, 2, 3]
b = "xyz"
c = (None, True)
>>> zip(a, b, c) # [(1, 'x', None), (2, 'y', True)]
```

- `compile(source, filename, mode, flag, dont_inherit, optimize)` - Компилирует переданную строку в исполняемый код
- `exec` или `eval` - используются для запуска скомпилированного кода. Обе функции непригодны для сложных конструкций
  кода.

### Тестирование кода

Цели:

- Прооверка правильности реализации кода
- Проверка обработки внештатных ситуаций и пограничных условий
- Минимизация последствий (дополнительной работы по отладке и нахождению причин багов)

Виды тестирования (?):

- unit-тесты (модульные) - проверка корректности выходных данных
- функциональное - проверка функциональности кода (связанные между собой функции)
- системное
- интеграционное - проверка взаимодействия нескольких систем между собой
- регресионное - тесты, делающиеся исходя из ошибок
- тесты производительности
    - нагрузочное
    - стресс

**TDD (Test Driven Development)** - техника разработки ПО, которая состоит из повторения циклов разработки: сначала
пишется тест, затем пишется код, позволяющий пройти тест, а потом делается рефакторинг кода и после всё по новой.

**coverage** - библиотека для проверки покрытия тестами (при использовании TDD обеспечивается наилучшее покрытие
тестами).

Инструменты для тестирования в Python:

- `doctest` - тесты проводятся по документации функции. Внутри документации пишутся вызовы функции так, как будто
  прописываем их в консоли. Не рекомендуется к использованию, т.к. убирает основной функционал документации.
- `unittest`
- `pytest`
- `factory_boy` - модуль для генерации разнообразных объектов по заданным параметрам
- `selenium` - эмуляция работы браузера, используется для парсинга, теста различных веб-сервисов

### Unit-тесты

Это встроенный модуль для тестирования корректности выводимых значений. Поддерживает автоматизацию тестов.
Для написания тестов используется `class Test<имя_класса>`, классы наследуется от `unittest.TestCase`, внутри него
пишутся тесты.
Все тесты выглядят следующим образом:

``` python
class TestString(unittest.TestCase):
    def test_<имя_функции>(self):
        #test code here
```

Функция строго должна начинаться с `test_`, чтобы тесты правильно отработали (вообще запустились). Непосредственно для
проверки корректности значений,
используются [функции](https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertEqual) `assert`.

Методы автоматизации:

- `setUp()` - установки, запускаемые перед каждым тестом
- `tearDown()` - очистка, запускаемая после каждого теста

### Mock-объект

**mock** - пустой объект, который эмулирует поведение некого реального объекта. Mock выдаёт тот результат, который
ожидается от реального объекта при исправной работе, поэтому использование mock-объекта позволяет сэкономить время при
тестировании и избежать каких-то фантомных ошибок (долгая загрузка ресурсов из интернета, прерывания интернет соединения
и т.д.).

Атрибуты mock (дописать):

- `called` - вызывался ли объект
- `call_count` - кол-во вызовов
- `call_args` - аргументы последнего вызова
- `call_args_list` - список всех аргументов
- `method_calls` - аргументы обращений к вложенным методам и атрибутам
- `mock_calls` - то же самое, но в целом и для самого объекта, и для вложенных

Больше о mock-объекте:

- [Тык](https://realpython.com/python-mock-library/)
- [Тык](https://docs.python.org/3/library/unittest.mock.html)

## Домашняя работа (2 лекция):

- написать функцию, которая парсит json-строку по списку необходимых полей и значений (`required_fields` и `keywords`)
- написать декоратор, который выводит среднее время выполнения последних k вызовов функции
- использовать mock-объект при тестировании
- узнать степень покрытия кода тестами (coverage)
- использовать `flake8` и `pyling` для проверки кода
- использовать `factory boy` для генерации данных

# Лекция №3 (12.10.23)

## Тема: ООП. Классы.

Класс - шаблон для описания / создания экземпляра и его параметров. Удобен при работе с различными объектами, для
которых можно задать пул параметров и их действий.

ООП - парадигма программирования, в которой для реализации различных логик используются классы. Основные принципы этой
парадигмы - наследование, инкапсуляция и полиморфизм.

### Классы и их атрибуты (поля)

- Для создания используется ключевое слово `class <name>`. Правила наименования аналогичны переменным, но используется
  CamelCase
- Для наследования после имени класса в круглых скобках указывается класс-родитель (по умолчанию класс наследуется от
  класса `object`)
- Поля, объявленные вне конструктора являются полями класса (общими для всех экземпляров). Поля внутри конструктора
  относятся к конкретному экземпляру класса. Поля класса нельзя изменить через экземпляры
- Модификаторы доступа (является формальным соглашением между разработчиками):
    - public: переменные без знака подчёркивания в начале `self.name`
    - protected: 1 знак подчеркивания в начале `self._protected`, доступен классам наследникам
    - private: 2 знака подчёркивания в начале `self.__private`, доступен только внутри этого класса
- После создания класса, в него можно добавлять поля с помощью `__dict__[<name>] = <value>`, причём name должен
  являться `str`. Поля с 2 нижними подчеркиваниями, объявленные таким образом, будут являться **public**!
- Значения полей можно получать с помощью `getattr(<object>, <name>)`, где `object` - экземпляр класса, а `name` - имя
  поля
- Поля можно использовать, даже если они будут добавлены в класс уже после его инициализации, но надо учитывать способы
  занесения переменных в `__dict__`
- Обратиться к родительскому классу можно с помощью `super()`

### Методы классов

- Все магические методы (использующие логику языка) начинаются и заканчиваются двумя нижними подчёркиваниями, существуют
  у каждого класса
- Во всех методах объекта, первым параметром передаётся ссылка на объект, от которого вызывается метод (его принято
  называть `self`)
- Методы класса сопровождаются декоратором `@classmethod`, первый параметр принимает ссылку на класс (принято
  называть `cls`). Эти методы работают с классом, а не с его экземпляром
- Статические методы определяются декоратором `@staticmethod`, они не привязаны ни к классу, ни к экземпляру,
  используются для разделения логик по пространствам имён, к которым они относятся (аналог namespace в C++). То есть
  если существует функция, которая имеет смысл только лишь в рамках созданного класса, то есть смысл сделать её
  статической

```python
class Boo:
    @staticmethod
    def print_static():
        print("It's static method")

    @classmethod
    def print_cls(cls):
        print(f"It's class method for {cls.__name__}")

    @classmethod
    def create(cls):
        print("Class method create")
        print(type(cls))
        return cls(44)

    def __init__(self, value):
        self.val = value
        print(f"Initializing instance with value {self.val}")

    def __str__(self):
        return f"{self.__class__.__name__}:{self.val=}"
```

### Магические методы и атрибуты

- `__new__` - статический метод, создаёт новый экземпляр класса, после чего вызывает у этого экземпляра
  метод `__init__`, пример использования - паттерн проектирования Singleton
- `__del__` - деструктор экземпляра класса, вызывается при удалении объекта (использование `del` или выход за пределы
  видимости имени), используется для закрытия (освобождения) различных ресурсов, соединений и прочего
- `__name__` - название класса
- `__module__` - модуль, в котором объявлен класс
- `__qualname__` - fully qualified name (с указанием всех базовых)
- `__doc__` - docstring
- `__annotations__` - аннотация статических полей класса (Python >= 3.10)
- `__dict__` - namespace класса (все поля принадлежащие классу)
- `__bases__` - базовые классы
- `__base__` - базовый класс, указанный первым по порядку
- `__mro__` - кортеж классов, упорядоченный по вызову функции super
- Если при поиске атрибута с помощью `__getattribute__` будет вызвана ошибка, то только после этого будет вызван
  метод `__getattr__`. Используя этот принцип, можно создать атрибут со значением по умолчанию, если он не был найден
  при вызове `getattribute`
- `__repr__` - представление объекта.
- `__str__` - вызывается функциями, обрабатывающие объект, как строку: `str`, `print`, `format`
- `__format__` - вызывается при форматировании строки
- `lt` / `le` / `eq` / `ne` / `gt` / `ge` - методы, определяющие сравнения объектов
- [Арифметические операторы](https://habr.com/ru/articles/186608/#:~:text=%D0%BE%D0%B1%D1%80%D0%B5%D0%B7%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%B4%D0%BE%20%D1%86%D0%B5%D0%BB%D0%BE%D0%B3%D0%BE.-,%D0%9E%D0%B1%D1%8B%D1%87%D0%BD%D1%8B%D0%B5%20%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B,-%D0%A2%D0%B5%D0%BF%D0%B5%D1%80%D1%8C%20%D1%80%D0%B0%D1%81%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B8%D0%BC%20%D0%BE%D0%B1%D1%8B%D1%87%D0%BD%D1%8B%D0%B5)
- [Отражённые арифметические операторы (операнд прибавляемого типа находится слева)](https://habr.com/ru/articles/186608/#:~:text=%D0%9E%D1%82%D1%80%D0%B0%D0%B6%D1%91%D0%BD%D0%BD%D1%8B%D0%B5-,%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B,-%D0%9F%D0%BE%D0%BC%D0%BD%D0%B8%D1%82%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D1%8F)
- [Магия контейнеров](https://habr.com/ru/articles/186608/#:~:text=%D0%B8%20next.-,%D0%9C%D0%B0%D0%B3%D0%B8%D1%8F%20%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%BE%D0%B2,-%D0%91%D0%B5%D0%B7%20%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%B5%D0%B9%D1%88%D0%B5%D0%B3%D0%BE%20%D0%BF%D1%80%D0%BE%D0%BC%D0%B5%D0%B4%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)
- `__hash__` - правило для хеширования объекта. Для использования объекта в hashable коллекциях, необходима реализация,
  как `__eq__`, так и `__hash__`
- `__slots__` - явное указание всех возможных атрибутов, при том добавить после их будет невозможно. Позволяет экономить
  память и время на создание При использовании этого метода пропадают поля `__dict__` и `__weakref__`
- `__init_subclass__` - вызывается при создании экземпляра класса-наследника

Больше о магических методах: [ТЫК](https://habr.com/ru/articles/186608/)

Работа с геттером / сеттером, свойствами:

- `@property` используется для определения свойства (геттера), которое является приватным. Имя функции должно
  совпадать с именем приватного поля. Часто может использоваться в комбинации с логикой прав доступа / просмотра тех или
  иных значений.
- `@<name>.setter` используется для создания сеттера, где `name` - имя приватного поля. Сеттеры удобны тем,
  что они позволяют делать предобработку значения перед его присваиванием
- `@<name>.deleter` используется при удалении свойства
- Все выше указанные случаи можно реализовать без декораторов, создав функции и передав их в конструктор `property`
- С помощью свойств также удобно создавать read/write - only поля. Например, при попытке прочитать свойство, можно
  возвращать исключение с ошибкой доступа

Порядок поиск атрибута у `obj`:

1. Сам объект (`obj.__dict__` и его системные атрибуты)
2. Класс экземпляра (`obj.__class__.__dict__`)
3. Классы-родители (`obj.__class__.__mro__`)

### Наследование. MRO. Множественное наследование

MRO - method resolution order - порядок разрешения методов. Данный порядок сообщает python о том, из какого
класса-предка необходимо вызвать метод, если тот не был обнаружен в классе-наследнике.

Магический метод `__mro__` возвращает кортеж классов, в которых будет искаться необходимый метод
В случае множественного наследования, старшинство классов-предков определяется слева направо в порядке указанном при
объявлении:

```python
class A:
    pass


class B:
    pass


class C(A, B):
    pass


C.mro()  # C -> A -> B -> object


class C(B, A):
    pass


C.mro()  # C -> B -> B -> object
```

# Лекция №4 (19.10.23)

## Тема: Метапрограммирование. Дескрипторы. Абстрактные классы

Дескриптор - объект, у которого есть атрибут со "связанным поведением". Это атрибут, при доступе к которому, его
поведение переопределяется методом протокола дескриптора (`__get__`, `__set__`, `__delete__`). При определении хотя бы
одного из этих методов, любой класс автоматически становится дескриптором, работа которого видоизменяется под капотом
самого языка

- Если определены все методы, то этот объект является дескриптором
- Если определены только `get` и `set`, то объект является data дескриптором
- Если определен только `get`, то объект является non-data дескриптором

Дескрипторы определяются, как атрибуты класса, они взаимодействуют с экземплярами класса.

По большей части, дескрипторы похожи на свойства полей, но дескрипторы могут применяться для полей разных классов, а
свойства придётся прописывать каждый раз заново. То есть, дескрипторы это шаблоны по обработке полей, разрешающие
переиспользование, а также избавляют от повторения кода

Методы, использующиеся в дескрипторах:

- `__set_name__(self, owner, name)` - вызывается при создании класса-владельца `owner`, в котором находится этот
  атрибут. В функцию будет передан класс владелец и имя атрибута (в классе владельца)
- `__get__(self, obj, objtype)` - вызывается при получении значения поля дескриптора
- `__set__(self, obj, val)` - вызывается при установке значения поля дескриптора
- `__delete__(self, obj)` - вызывается при удалении поля дескриптора

Поля дескрипторы имеют более высокий приоритет над обычными полями. Если создать поле дескриптор с одним именем, а потом
создать такое же поле с помощью `__dict__`, то будет вызываться именно поле дескриптор.
При работе с дескрипторами для нескольких экземпляров возникает проблема влияния одного экземпляра на другой.
В качестве решения проблемы можно использовать словарь `obj:val` внутри дескриптора, но это приведёт к урезанному
функционалу, сложности с реализацией и тд

Следовательно, для решения проблемы можно использовать установку и считывание атрибутов для каждого объекта. То есть,
при установке значения, мы присвоим переданному объекту атрибут с помощью `setattr`, а при получении будем
использовать `getattr`, что гарантирует нам использование каждым объектом своего собственного атрибута

### Метаклассы

Метаклассы - это классы, экземпляры которых являются классами.

Встроенный в ЯП метакласс - `type`